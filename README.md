# prokopishena_students


## Використання методів рефакторингу

### ****Не визначені змінні** (Issue Type: Undefined Variables)

#### Проблема:
- `require' is not defined (no-undef)`
- `'__dirname' is not defined`
- `'re' is not defined`

#### Метод рефакторингу для вирішення:
- *Introduce Local Extension* - запровадження локального розширенняапровадження локального розширення

### **Не використовувана змінна** (Issue Type: Unused Variables)

#### Проблема:
- `'newApplication' is assigned a value but never used` на рядку 257.

#### Метод рефакторингу для вирішення:
- *Dead Code* - видалення непрацюючого коду

### **Примітивне дублювання коду** (Issue Type: Code Duplication)

#### Проблема:
Дублювання коду в обробниках запитів для отримання даних з бази (наприклад, `/fetch-select-data/faculties`, `/fetch-select-data/specialties`, `/fetch-select-data/benefits`, `/fetch-select-data/dormitories/:dormitoryId`).

#### Метод рефакторингу для вирішення:
- *Duplicate Code* — витягнення спільної логіки в окрему функцію 

### **Складність і зрозумілість коду** (Issue Type: Code Complexity)

#### Проблема:
Обробник POST-запиту для подачі заявки має великий обсяг коду з перевірками та створенням записів у базі даних. Це може ускладнити підтримку коду при необхідності змін.

#### Метод рефакторингу для вирішення:
- *Extract Method* витягнення логіки для обробки введених даних в окрему функцію 

### **Відсутність обробки помилок для асинхронних функцій** (Issue Type: Error Handling)

#### Проблема:
Не всі асинхронні функції мають належну обробку помилок.

#### Метод рефакторингу для вирішення:
- *Introduce Assertion* - для всіх асинхронних операцій додано обробку помилок, особливо в обробниках маршрутів.

### **Використання `expect` всередині умовного блоку** (Issue Type: Jest Testing Rule Violation)  

#### Проблема:
Функція `expect` викликається умовно (наприклад, всередині `if`, `for`, `while`, `try/catch`), що може призвести до того, що деякі перевірки не будуть виконані.  

#### Метод рефакторингу для вирішення:
- *Decompose Conditional* - розбиття складних умовних конструкцій на окремі функції або перевірки, щоб усунути умовну логіку навколо викликів expect

### **Довгий список параметрів**

#### Проблема:
У маршруті POST /submit_application у файлі form_application.js використовується велика кількість параметрів, отриманих через деструктуризацію req.body

#### Метод рефакторингу для вирішення:
- *Introduce Parameter Object* — групування пов’язаних параметрів у єдиний об’єкт applicationData

### **Дубльований код**

#### Проблема:
У файлі select.js функції fetchDataAndPopulateSelect і fetchSpecialtiesByFacultyId містять схожу логіку для заповнення елементів select даними, отриманими з сервера

#### Метод рефакторингу для вирішення:
- *Duplicate Code* — витягнення спільної логіки в окрему функцію populateSelectFromData, яка використовується обома функціями

### **Магічні числа та рядки**

#### Проблема:
Число 5500 (порт сервера) та рядки типу 'fetch-select-data/faculties' використовуються напряму без пояснень.

#### Метод рефакторингу для вирішення:
- *Replace Magic Number with Symbolic Constant*— заміна захардкоджених чисел на іменовані константи (PORT, STATUS_OK, STATUS_NOT_FOUND, STATUS_SERVER_ERROR).

### **Повернення кодів помилок**

#### Проблема:
У маршруті GET /fetch-select-data/specialties/:facultyId у файлі form_application.js повертається код стану 404 із JSON-повідомленням про помилку, що змішує обробку помилок із нормальним потоком виконання.

#### Метод рефакторингу для вирішення:
- *Replace Error Code with Exception* — заміна повернення коду стану на викидання виключення, яке обробляється в блоці try-catch

### **Кілька обов'язків**

#### Проблема:
файл form_application.js обробляє налаштування сервера, визначення моделі та численні обробники маршрутів (наприклад, для факультетів, спеціальностей, пільг, гуртожитків і цін), надаючи йому занадто багато обов’язків і порушуючи принцип єдиної відповідальності (SRP).

#### Метод рефакторингу для вирішення:
- *SOLID* — Обробники маршрутів переміщено в окремі модулі маршрутизатора (наприклад, facultyRouter , specialtyRouter , benefitRouter , dormitoryRouter , priceRouter ). Кожен модуль обробляє маршрути для певної сутності, зменшуючи зв’язок і гарантуючи, що кожен модуль має одну причину для зміни.

## Обґрунтування методів рефакторингу

### Introduce Local Extension
- *Причина вибору*: Обраний метод  дозволяє запровадити локальні змінні, що вирішує проблему з невизначеними змінними, які можуть викликати помилки на етапі виконання.

- *Функціональність*: Цей метод дозволяє визначити змінні безпосередньо в контексті функції або блоку, що полегшує відслідковування і запобігає глобальним помилкам.

- *Покращення*: Це покращує читабельність коду, оскільки локальні змінні чітко відокремлені від глобальних, і зменшується ризик помилок при їх використанні.

### Dead Code
- *Причина вибору*: Обраний метод  підходить для видалення зайвих змінних, які не використовуються, оскільки це забезпечує чистоту коду.

- *Функціональність*: ЦВидалення непотрібних змінних дозволяє знизити складність коду і робить його більш ефективним.

- *Покращення*: Це покращує продуктивність, зменшує обсяг коду та підвищує його підтримуваність, позбавляючи від зайвих елементів.

### Duplicate Code
- *Причина вибору*: Обраний метод  дозволяє уникнути дублювання логіки у коді, що часто призводить до помилок та ускладнює супровід.

- *Функціональність*: Витягнення спільної логіки в окрему функцію дозволяє централізувати зміни та спростити тестування.

- *Покращення*: Це підвищує читабельність і підтримуваність коду, оскільки зміни потрібно вносити лише в одному місці, що зменшує ймовірність помилок.

### Extract Method
- *Причина вибору*: Обраний метод  ддозволяє розділити великий обробник на менші, що спрощує тестування та зміну логіки.

- *Функціональність*: Цей метод зменшує складність функції, роблячи її більш читабельною та зрозумілою.

- *Покращення*: Це значно покращує підтримуваність коду, роблячи його простішим для розуміння та модифікацій.

### Introduce Assertion
- *Причина вибору*: Обраний метод  необхідний для забезпечення коректної обробки помилок у всіх асинхронних функціях, що запобігає несподіваним крахам.

- *Функціональність*: Цей метод дозволяє асинхронно перевіряти і обробляти помилки, гарантуючи стабільність додатку.

- *Покращення*: Це покращує надійність додатку, оскільки допомагає вчасно реагувати на помилки, зменшуючи ймовірність їх непомічення.

### Decompose Conditional
- *Причина вибору*: Обраний метод  дозволяє розбити умови на простіші перевірки, що забезпечує коректне виконання тестів

- *Функціональність*: Розбиття складних умов допомагає уникнути помилок, пов'язаних з непередбачуваними викликами expect у умовних блоках.

- *Покращення*: Це забезпечує більшу надійність тестування, оскільки всі перевірки виконуються в очікуваних умовах.

### Introduce Parameter Object
- *Причина вибору*: Обраний метод  підходить для групування пов'язаних параметрів в один об'єкт, що знижує складність та покращує структуру функцій

- *Функціональність*: Створення єдиного об'єкта для передачі даних дозволяє зменшити кількість параметрів у функціях та зробити їх більш логічними.

- *Покращення*: Це зменшує складність коду та робить його більш зручним для подальшої модифікації. 

### SOLID 
- *Причина вибору*: Обраний метод допомагає розділити обов'язки між різними модулями, що сприяє підтримці принципу єдиної відповідальності.

- *Функціональність*: Переміщення обробників маршрутів в окремі модулі знижує складність основного файлу і полегшує його підтримку.

- *Покращення*: Це зменшує зв’язок між компонентами та покращує підтримуваність коду, дозволяючи вносити зміни в окремі модулі без впливу на інші частини програми.

### Replace Magic Number with Symbolic Constant 
- *Причина вибору*: Обраний метод  допомагає зробити код більш читабельним і зрозумілим.

- *Функціональність*: Заміна захардкоджених значень на іменовані константи робить код легшим для розуміння і підтримки.

- *Покращення*: Це полегшує зміну значень та зменшує ймовірність помилок при їх використанні в різних частинах програми

### Replace Error Code with Exception
- *Причина вибору*: Обраний метод  дозволяє централізувати обробку помилок і забезпечує кращу зручність для розробників.

- *Функціональність*: Використання виключень для обробки помилок дозволяє чітко розмежувати нормальний потік виконання та обробку помилок.

- *Покращення*: Це покращує структуру коду, роблячи його зрозумілішим і надійнішим у разі помилок.